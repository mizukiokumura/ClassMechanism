/* クラス型と参照
今まで仮想世界と表現してきたものは、実際には、コンピュータのメモリ領域」である
そのため、この領域は、javaがプログラムを実行する際に、JVMが大量にメモリの領域
を使って準備するものでヒープ(heap)という。
newを用いてインスタンスを作り出すたびに、ヒープの一部の領域(通常は数十~数百バイト)が確保され、
インスタンスの情報を格納するために利用される。
そのため多くの属性をもつインスタンス程消費されるヒープ領域の容量は大きくなる。
インスタントとは=「ヒープの中に確保されたメモリ領域」に過ぎない。

public class Main {
  public static void main(String[] args) {
    Hero h; ←この行を実行すると、JVMが「Hero型の変数h」をメモリ内に準備。これにより、Hero型のインスタンスだけを中に入れる事ができる箱が準備された。
    h = new Hero(); ←ここが実行されると、ヒープ領域から必要な量のメモリを確保する。これで仮想世界に勇者という存在が生まれる。しかし、まだ生まれたものの、属性にはなんの値も入っていない状態。そしてこの行の実行が終了した後の状態としては、
    「h = 右辺の実行結果」という状態になり、hに右辺の実行結果が代入されているという事になる。ここで出てくる右辺の実行結果とは、
    newによって生成されるインスタンスのために確保されたメモリの先頭番地になる。仮に4000 ~ 4200番地だとすると「4000」という数値が代入されている。
    変数hに入っているアドレス(番地)情報の事を「参照」という。
    h.hp = 100; ←この行を実行した時の、JVMの動き方
    1、変数hの内容を調べると、「4000番地を参照せよ」と書かれている。
    2、メモリ内の4000番地にあるインスタンスのメモリ領域にアクセスし、その中のhpフィールド部分を100に書き換える。
    このように、まず変数から番地情報を取り出し、次にその番地にアクセスする、というJVMの動作を「参照解決」や「アドレス解決」という。
  }
}

クラス型と配列型を総称して「参照型」と呼ばれている。

もし同じクラスが複数違う変数に格納されていても、片方の値が変わってももう片方は変わる事がない、
この異なるインスタンスであれば、互いに影響を受けないことを「インスタンスの独立性」という。

public class Main {
  public static void main(String[] args) {
    Hero h1;
    h1 = new Hero();
    h.hp = 100;
    Hero h2;
    h2 = h1; ←ここでコピーされているのは「勇者インスタンスそのもの」ではなく番地の情報が入っている。
    h2.hp = 200;
    System.out.println(h1.hp); ←200が出力される。
  }
}

勇者インスタンスh1のために確保してあるメモリの先頭番地を思い出す。
newを記述した回数だけ、仮想世界にインスタンスが生まれるということ。
Sword.java
public class Sword {
  String name;
  int damage;
}
Hero.java
public class Hero {
  String name;
  int hp;
  Sword sword;
  public void attack() {
    System.out.println(this.name + "は攻撃した！");
    System.out.println("敵に5ポイントのダメージを与えた！");
  }
}

今回は新しく追加されたフィールド(変数)は「sword」は、Sword型(クラス型)です、
このようにフィールドにクラス型の変数を宣言することもできる。
このように「あるクラスが別のクラスをフィールドとして利用している関係」を
「has-a」の関係という。has-aと呼ぶ理由は下記のような英文が自然に成立するから。
Hero has-a Sword（勇者は剣を持っている）
Main.java
public class Main {
  public static void main(String[] args) {
    Sword s = new Sword();
    s.name = "炎の剣";
    s.damage = 10;
    Hero h;
    h = new Hero();
    h.name = "ミナト";
    h.hp = 100;
    h.sword = s;
    System.out.println("現在の武器は" + h.sword.name );
  }
}

クラスの型をメソッドの引数や戻り値に用いる
クラス型も他の型と同様にメソッドの引数や戻り値の型として利用することもできる。
Wizard.java
public class Wizard {
  String name;
  int hp;
  public void heal(Hero h) { ←引数がHero型
    h.hp += 10; 勇者のHPに10を加えている。
    System.out.println(h.name + "のHPを10回復した!");
  }
}

ここで問題なのは仮想世界にも勇者が複数生み出されている可能性もあるので、
呼び出される時に「どの勇者を回復させるのか」を引数hとして受け取る必要がある。

String型とは
String型はint型やdouble型の仲間ではなく、クラス型です。
実はjavaが準備してくれていたクラスを利用していた。

String型は
・java.lang パッケージに宣言されている。
 java.landパッケージに所属するクラスを使う場合は特例としてimport文を記述する必要がない。
 この特例のおかげで、本来は「java.lang.String s;」と宣言する必要があるところを、String
 とかけばよくなった。

・二重引用符("")で文字列を囲めばインスタンスを生成して利用できる
通常、インスタンスを生成するにはnew演算子を使って利用する必要がある。
しかし文字列はプログラムの中で多用されるため、その都度newを書いていては
ソースコードがnewだらけになってしまう。そこで"で文字列を囲めば、その文字列情報を持ったStringインスタンスを利用できる
という特例になった。
newを使って文字列のインスタンスを生成する方法(非推奨)
public class Main {
  public static void main(String[] args) {
    String s = new String("こんにちは");
    System.out.println(s);
  }
}

・「コンストラクタ」
newでインスタンスを生成した直後、必ずフィールドの初期値を代入しています。
Hero h = new Hero(); ←この時点で初期値が代入されている。
なぜならnewで生み出されたばかりのインスタンスフィールド(nameやhp)には、まだ何も入っていないから。
newで生成された時、各フィールドは初期値が設定されている。
          型            |    値      |
int型などの数値型         | 0          |
char型(文字)            | ¥u0000     | 
boolean型               | false      |
int[]型などの配列型       | null       |
String型などのクラス型    | null       |

インスタンスが産まれた直後に自動実行される処理はあらかじめ定義できるようになっている。

public class Hero {
  String name;
  int hp;
  Sword sword;
  public void attack() {
    System.out.println(this.name + this.sword.name +"で攻撃した！" );
    System.out.println("敵に5ポイントのダメージを与えた！");
  }
  public Hero() { ←コンストラクタとして定義されている。
    this.hp = 100;
  }
}

本来他の通常のメソッドは「呼び出されない限り動かない」ものなのだが
Hero();(クラス名();)メソッドだけは「このクラスがnewされた直後に自動的に実行される」という特別な性質を持っている。
このようなメソッドを「コンストラクタ(constructor)」と呼ぶ(rubyのinitializeメソッドに似ている。)
コンストラクタがあるお陰でmain側で初期値を代入する必要がなくなる。

コンストラクタは、開発者が直接呼び出すものではない点に注意が必要。
コンストラクタは、直接呼び出すことができない。

----------------
コンストラクタは直接呼び出せない！
コンストラクタはインスタンスの生成時にJVMによって呼び出されるものであり、
開発者がプログラムで直接呼び出す手段は用意されていない
----------------

・コンストラクタの定義方法
-------------------------------
コンストラクタと見なされる条件
1,メソッド名が「クラス名」と「完全」に等しい
2,メソッド宣言に戻り値が記述されていない(voidもだめ)
-------------------------------

コンストラクタの定義-----------------------
public class クラス名 {
  クラス名() {
    自動的に実行する処理
  }
}
----------------------------------------

コンストラクタに情報を渡す場合
HPフィールドは初期値を設定するという単純なコンストラクタですみましたが、
勇者の名前などは作った勇者の数だけ名前が異なるはずなので、
コンストラクタ側で「毎回異なる追加情報」を引数で受け取れるように宣言することができる。
public Hero(String name) { 
    this.hp = 100;
  }
  こうすることでnewするときに名前の初期値も指定できるようになった。
 上記のようなHeroコンストラクタを利用する場合はコンストラクタに渡すべき引数をnewする時に指定する
。

public class Main {
  public static void main(String[] args) {
    Hero h1 = new Hero("ミナト"); ←インスタンス生成後、JVMがコンストラクタを呼び出す際に「ミナト」を渡してもらえる。

     System.out.println(h1.hp);
     System.out.println(h1.name);
  }
}

上記のようなHeroコンストラクタを作ってしまうと、インスタンスを生成するときに、必ず名前を指定する必要が
生じてしまうというデメリットもあるので、その問題を解決するために「引数を受け取らないコンストラクタ」も同時に定義することで解決できるようになる。

public class Hero {
  String name;
  int hp;
  Sword sword;
  public void attack() {
    System.out.println(this.name + this.sword.name +"で攻撃した！" );
    System.out.println("敵に5ポイントのダメージを与えた！");
  }
  public Hero(String name) { 
    this.hp = 100;
    this.name = name;
  }

  public Hero() {
    this.hp = 100;
    this.name = "ダミー";
  }
}

複数のコンストラクタが定義されていた場合-----------------
newする時に渡した引数の型・数・順番に一致するコンストラクタが動作する(動作するコンストラクタは１つのみ)
----------------------------------------------------

コンストラクタをオーバーロードしたクラスの利用
public class Main {
  public static void main(String[] args) {
    Hero h1 = new Hero();

    Hero h2 = new Hero("瑞樹");
     System.out.println(h1.hp);
     System.out.println(h1.name);
     System.out.println(h2.hp);
     System.out.println(h2.name);
  }
}

暗黙のコンストラクタ
javaでは、全ての「クラス」はインスタンス化に際して必ず何らかのコンストラクタを実行することになっている。
なので、本来全てのクラスは「最低でも1つ以上のコンストラクタ定義を持っていなければならない。」

public class Map {

  public Map() {
    
  }
}
上記のように中身のないコンストラクタを定義するのは面倒なので、javaでは特例を儲けている。

コンストラクタの特例---------------------------
クラスに1つもコンストラクタが定義されていない場合に鍵って「引数なし、処理内容なし」のコンストラクタ(デフォルトコンストラクタ)が
コンパイル時に自動的に追加されている。
--------------------------------------------

この特例によって引数なしコンストラクタがこっそり自動的に定義されたため、「new Hero();」によるインスタンス化が可能であった。

重複した処理を容易く他のコンストラクタに適用する方法。

public Hero(String name ) { // コンストラクタ①
  this.hp = 100;
  this.name = name;
}
public Hero() { // コンストラクタ②
  this.Hero("ダミー"); ←この記述ではエラーになってしまう。
}

上記のような記述ではエラーになってしまう、コンストラクタを呼び出せるのはJVMだけであり、
開発者が呼び出すのはできないためです。
その代わりコンストラクタの起動を依頼することはできる。

同一クラス内の別のコンストラクタの呼び出しをJVMに依頼する-------------------
this(引数);
*コンストラクタの先頭に記述する必要がある。
-------------------------------------------------------------------

  public Hero() {
    this.hp = 100;
    this("ダミー");
  }

 第９章まとめ

 クラス型と参照
 ・クラス型変数の中には、「インスタンスの情報が格納されているメモリの先頭番地」が入っている。
 ・あるクラス型変数を別の変数に代入すると、番地情報だけがコピーされる。
 ・クラス型は、フィールドでの型や、メソッドの引数・戻り値の型としても利用できる。

 コンストラクタ
 ・「クラス名と同一名称で、戻り値の型が明記されていないメソッド」はコンストラクタとして扱われる。
 ・コンストラクタは、newによるインスタンス化の直後に自動的に実行される。
 ・引数をもつコンストラクタを定義すると、newをする際に引数を指定してコンストラクタを実行させることができる。
 ・コンストラクタはオーバーロードにより複数定義できる。
 ・クラスにコンストラクタ定義が一つもない場合に鍵って、コンパイラが
 「引数なし・処理内容なし」のデフォルトコンストラクタを自動的に定義してくれる。
 ・this()を用いれば、同一クラスの別のコンストラクタの呼び出しをJVMに依頼することができる。

 練習問題の解答
 9-1
 public class Thief {
   String name;
   int hp;
   int mp;

   public Thief(String name, int hp, int mp) {
     this.name = name;
     this.hp = hp;
     this.mp = mp;
   }

   public Thief(String name, int hp) {
     this(name, hp, 5);
   }
   public Thief(String name) {
     this(name, 40);
   }
 }

 9-2
 実行結果
 25 : 25
 25 : 35
この実行結果が出た理由は、healメソッドの呼び出しにint型のbaseHpを渡しても呼び出し元の値は変化しない。
一方、Thiefインスタンスを渡すと呼び出し元でもhpが変化する。
 これは、引数がint型の場合、変数baseHpの値が引数hpにコピーされる値私により、メソッド内での代入は呼び出し元へは影響しないため。
 引数がクラス型の場合、変数tが示すアドレスが引数thiefにコピーされる参照渡しにより、t.hp,とthief.hpはメモリの同じ場所を指すことになる。
 そのため、thiefへの代入がt.hpにも反映しているように見える。

 フィールド初期値の設定手段-------------------------
 あるクラスのフィールドに初期値を代入したい場合、次の４つの方法がある。
 (1)フィールド宣言時に初期値を指定する。
 (2)静的初期化ブロックでフィールドに値を代入する。
 (3)初期化ブロックでフィールドに値を代入する。
 (4)コンストラクタでフィールドに値を代入する。

JVMはインスタンスの生成後に(1)~(4)の順で処理を実行する。
一般的には1~4のどちらかの方法を選ぶことになるが、混乱を避けるために、通常はコンストラクタに任せるなど、ルールを統一しておく事をおすすめする。